/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package myapplication

import kotlin.math.* 

fun main(args: Array<String>) {
    // val intList = args.map { it.toDouble() }
    // val a = intList[0]
    // val b = intList[1]

    println(someSums(14,2,4))
}
// Serval vs Monster
typealias Monster = Double 
typealias Serval = Double
fun vs(x: Monster, y: Serval): Int {
    return Math.ceil(x/y).toInt()
}

// We love golf
fun loveGolf(k: Int, a: Int, b: Int): Boolean {
    return (a..b).toList().filter { it%k == 0 }.isNotEmpty()
}

// Some Sums
fun someSums(n: Int, a: Int, b: Int): Int {
    return (1..n).toList().filter { sumDigit(it) in a..b}.sum()
}
fun sumDigit(x : Int ): Int { // 各けたの和を返す関数
    return when (x<10) {
        true -> x
        else -> (x % 10) + sumDigit(x / 10)
    }
}

interface Rule {
    fun convert(input: Int): String
}

interface Command {
    fun execute(input: Int): String
}

class FizzRule constructor(): Rule {
    override fun convert(input: Int): String {
        return when(input%3 == 0) {
            true -> "Fizz"
            else -> ""
        }
    }
}

class BuzzRule constructor(): Rule {
    override fun convert(input: Int): String {
        return when(input%5 == 0) {
            true -> "Buzz"
            else -> ""
        }
    }
}

class EmptyRule constructor(): Rule {
    override fun convert(input: Int): String {
        return ""
    }
}

class CommandImpl constructor(
    private val rules: List<Rule>
) : Command {
    override fun execute(input: Int): String {
        var result = ""
        rules.forEach { rule ->
            result += rule.convert(input)
        }
        return result
    }
}

fun fizzBuzzExec(input: Int): String {
    return handleFizz(input) + handleBuzz(input)
}

fun handleFizz(input: Int): String {
    return when(input%3) {
        0 -> "Fizz"
        else -> ""
    }
} 

fun handleBuzz(input: Int): String {
    return when(input%5) {
        0 -> "Buzz"
        else -> ""
    }
} 