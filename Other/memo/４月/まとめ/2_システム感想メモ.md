## 苦労・失敗・工夫
- 関数型プログラムの導入
    - Resource.kt, MonadResult.kt というモナディック?な型クラスを自作して関数型のスタイルでデータを処理する記法を採用
    - 処理の流れが追いやすい、副作用が限定的なのでバグが特定しやすいといったメリットがある。
- 音声データ
    - 想定通りにいかないことが多かった。
        - マイク-> Binaryデータ -> ☆flac形式のBinary変換 -> ☆Base64エンコードでAPI送付 -> GCPSpeechToTextで解析
            - ☆: Binaryの一部が0埋めされる不具合があった、Kotlinでエンコードすると解析できないことが多かった　
            - 1つ目は一時保存ファイルを逐一作成したら欠落は無くなった、二つ目はBase64ではなくBinaryで直接データ送付したら不具合無くなった。
        - そもそもflac形式変換をサーバでやりたかったが、Kotlin/Javaだとまだよいライブラリが見つからないorなぜか使えなかった。
- KMMに適したアーキテクチャの考察
    - KMMの特性上、Shardモジュールの複雑化が懸念だった
        - Sharedの中もモジュール分割したかったがビルドが通らずうまくいかなかった
        - パッケージでレイヤー分けることになるので依存方向の強制が難しい。
        - サーバをかませて処理の大部分を移譲することにした。
    - KoinDIとの相性からかiOSのNSObjectがShaerd側に注入できないことがあった。ので、フレームワークのインスタンスもKMM上で適切に扱ってくれるライブラリを選んだ（RealmやKtorなど）
- お金面
    - シンプルにGCPはお金が飛ぶ。SpeechToText,CloudStorage,SQL,CloudRunといろいろ試しに突っ込んでたら予想費用が４万ってでて、ローカルでやるようにした（あたりまえ）

## 今後の所感
- KMMは使っていきたい
    - iOSの実装は後発だったが、ロジックのほとんどがAndroid側の打鍵で担保されているのでUIに集中できるのがよい
    - ChatGPTがあれば、JetPackCompose->SwiftUIへの変換は簡単にできてしまう。（もちろん再考は要）
- 音声や画像のデータ処理をバイナリレベルで探索したい
    - フォーマットの違いがどういうデータ構造によって表されているのかを知っておきたい
- 関数型プログラムが面白い
    - 処理が追いやすい
    - 関数の組み合わせで全体の処理ができていく感覚が楽しすぎる
- カンバンのAnalyzeがなくなることはない