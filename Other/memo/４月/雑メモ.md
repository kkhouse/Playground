アプリを使用した英会話手順
- ユーザがしゃべる
- Android:MediaRecorderで音声認識
- SpeechToTextAPIでText化
https://cloud.google.com/speech-to-text?hl=ja
- OpenAI ChatCompletionへユーザの会話内容を送信
- 上記のレスポンスにて、AIの返答をUIに表示
- TextToSpeechAPIにてAIの返答のみ音声化
https://cloud.google.com/text-to-speech?hl=ja
- 完了と同時に、会話内容をGoogle Cloud Storage（GCS）にログ

↑までのシーケンス

```mermaid
sequenceDiagram
    participant User
    participant App
    participant MediaRecorder
    participant SpeechToTextAPI
    participant OpenAIChatCompletion
    participant TextToSpeechAPI
    participant GoogleCloudStorage

    User ->> App: Speak
    App ->> MediaRecorder: Record voice
    MediaRecorder ->> App: Voice data
    App ->> SpeechToTextAPI: Convert voice data to text
    SpeechToTextAPI ->> App: User text
    App ->> OpenAIChatCompletion: Send user text
    OpenAIChatCompletion ->> App: AI response text
    App ->> TextToSpeechAPI: Convert AI response to voice
    TextToSpeechAPI ->> App: AI voice
    App ->> User: Display AI response and play AI voice
    App ->> GoogleCloudStorage: Log conversation
```



KMMによるKotlin -> Swiftの変換

```swift
import SwiftUI
import shared

struct ContentView: View {
    @ObservedObject private var viewModel = MyViewModel()

    var body: some View {
        VStack {
            Button(action: {
                viewModel.incrementCounter()
            }) {
                Text("count : \(viewModel.counter)")
            }
        }
    }
}

class MyViewModel: ObservableObject {
    @Published private(set) var counter: Int = 0
    private let myKmmViewModel: MyKmmViewModel

    init() {
        myKmmViewModel = MyKmmViewModel()
        myKmmViewModel.stateFlow.watch { [weak self] count in
            self?.counter = count
        }
    }


    func incrementCounter() {
        myKmmViewModel.incrementCounter()
    }
}

```

TODO 
- サーバー側
    - 通信の仕様整理 
        - 実装
    - DB仕様整理 OK -> データベース
        - 実装
    - AIチャットの整理 OK -> システムシーケンス
        - 実装
- モバイル側
    - 通信仕様の整理
    - スキーマの整理

後回し
- KMMのロジック整理
    - Swift UIの仕組み
    - データ受け渡しがどうなっているか
        - プリミティブ
        - Collection
        - data型など構造体
        - 具象クラスのオブジェクト
    - 特にFlowの部分のiOSへの連携手法
    - シーケンスにまとめてしまうか


- FlacからのBase64データが取れない SpeechToTextImpl#postSpeechToText -> これは最悪なくても良い
```
curlでの取得は可能な音声データ
JavaClientを通すと出来なくなる。
```


あいであおきば💡💡
- TextCompletionで文法添削？
- チャットアイコンからSystemのプロンプトを変更可能にする
- FloatingActionButtonで会話のリセット
- PixelWatchで簡易英語翻訳くらいはやりたい
- folding or tablet にて添削の部分をできるようにする？
- 言語の変更が可能、イギリス英語かアメリカ英語かなど、UIの最初に設定させてしまえばよい
- ストリーム処理をしてみる?
- サーバー側 versionCatalog導入
- 精度が悪ければもう一度
- ファイル解析の抽象化
- データの圧縮やストリーミング
- 英語の音声を集める

苦労
- 文字コードにハマった 
 -> GCPで保存するやり方に変更

工夫
- 関数型プログラムを意識
- システムを作り上げてみるって思いでやる


Material Design 3 階層
色とフォントとShapeを追ってみる




- スライド1
    - どんなサービス？
        - AIとの半音声英会話
        - KMMによるマルチプラットフォームを想定（現状Androidのみ）
        - システムとその背景はシステムシーケンスにまとめ
    - 他との利点
        - 音声認識もGoogleのAIモデルなので精度は高い（はず。。）

- スライド2
    - ありきたりでは？
        - Yes
            - Speeksというアプリに同じような機能がおしゃれにある
            - ChatGPTとChrome拡張機能を組み合わせれば英会話できる
                - 音声認識は拡張機能依存（おそらくAIモデルではない）
    - なぜつくったか
        - 裏の目的は友人をAIに憑依させること
            - モデリングの上で欲しい情報
                - 性格 : プロンプトを駆使すれば近いものは作れる可能性がある
                - 外観 : SNS漁ればいくらでも
                - 声 : このアプリで
            - モデリング方法
                - VertexAIによるローコード開発
        - 上記の学習でどのくらい近づくのかみたい。
        - なにより思いついたものを作っていく過程でいろんな技術に触るのがおもしろい

- スライド3
    - 工夫
        - AIモデルを使用するようにしていること
            - SpeechToText, TextToSpeech(WIP)
                - 音声認識はAndroid標準のものをつかったプロトタイプを作ったが限界を感じる部分が多かった
                    - 短文の認識しかできない
                    - タイムアウトがはやい、カスタマイズが困難
                    - https://qiita.com/KimKo/items/37e3052404d35b8d6129
            - OpenAI ChatCompletion
                - アプリ機能の核
        - 宣言方（関数型）のプログラム手法を意識したこと
            - 以下型クラスをつくって、中身をmap,filter,ford等ストリーム処理をしやすくした
                - Resourceという処理過程を表す文脈の型クラス（Kotlin.Resultを拡張したようなもの）
                    - Success<Data>
                    - Failure<ErrorInfo>
                - MonadResultという、アプリで欲しい処理結果を表す型クラス
                    - Loading
                    - Idle
                    - Success<Data>
                    - Failure<ErrorInfo>
        - UIはComposeであること
        - まだベータ版のKMMを導入してマルチプラットフォームの足場を作った
        - やることをカンバンボードで管理していること
            
    - 苦労
        - 音声データの扱いの難しさ
            - バイナリデータが欠落することがおおかった
                - PCMで取得したBinaryをFlacに返還する必要があったが、ファイルに一時保存が必要だったりと当初想定よりかなり手間取った
            - GCPのAPIでBase64の文字列返還した音声データを送付してもうまくいかない
                - Kotlinのクライアントだとだめ、curlだとうまくいくみたいなことがあってこの方法はやめた
        - こまかなTODOがかなり残ってる
            - UIまわり
            - やりたいこと
        - iOSがまだプロトタイプもできてない
            - GW全部費やしたが、想定の半分くらいしか進まず落ち込んでいる（ぐち）
