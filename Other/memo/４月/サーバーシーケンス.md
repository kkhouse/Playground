### 音声データのシーケンス図
ボツ
これはFlac形式の音声データをBase64のbyte配列にして送付するがその変換の過程でなんらかの文字情報が欠落する様子でKotlinと相性が悪い様子。Curlだとできるがこの方法は保留
```mermaid
sequenceDiagram
    participant User
    participant App as "Android or iOS"
    participant ServerA as "サーバA"
    participant GCP

    User ->> App: Flac形式の音声を送信
    App ->> App: FlacM形式の音声をバイト配列に変換
    Note over App: Flac, Base64, SampleRateHertz(16000), en-US
    App ->> ServerA: Base64（data）に変換後送信
    Note over App,ServerA: {"data": "byte","type": "audio/wav"}
    ServerA ->> GCP: 変換した音声データを送信
    GCP ->> ServerA: 変換結果を受信
    ServerA ->> App: 結果をBase64（data）に変換後送信
    Note over ServerA,App: {"data": "result","error":""}

    App ->> User: 結果を受信
```

採用
- サーバーをかます理由 : SpeechToTextのクライアントライブラリがモバイルに対応していない。
- サーバサイドの勉強

```mermaid
sequenceDiagram
  participant User
  participant MobileApp
  participant ServerA
  participant GoogleCloudStorage
  participant SpeechToText
  
  User->>MobileApp: Request to record and\nsave voice clip in FLAC format
  MobileApp->>ServerA: Send recorded voice clip\nalong with format and metadata
  Note over MobileApp,ServerA: ContentType.Audio.Flac
  ServerA->>ServerA : 形式確認
  Note over ServerA : Flac, SampleRate, en-US
  ServerA->>GoogleCloudStorage: Save the voice clip in\nGoogle Cloud Storage along with an ID
  GoogleCloudStorage-->>ServerA: Acknowledge that\nthe file has been saved successfully
  ServerA->>SpeechToText: Request for speech-to-text\nconversion using the saved ID
  SpeechToText-->>ServerA: Respond with the\nconverted text
  ServerA->>MobileApp: Send the text to\nthe mobile app
  MobileApp->>User: Display the text\nto the user
```

クライアントとのリクエスト- レスポンス
- リクエスト
```
Content-Type: audio/any or flac
body: flacBinaryData
```
- Response
```json
{
  "text":"recognition result text , notNull",
  /**
  * @param errorCode
  *  0 : 想定外
  *  1 : チャンクが多い
  *  2 : 空文字レスポンス or 結果が複数の異例ケース
  */
  "errorCode":"Int: 0~2, nullable"
}
```

ServerAのファイル保存->テキスト生成俯瞰
```mermaid

sequenceDiagram
    participant Client as Client
    participant AppRoute as Application:Route
    participant AppUseCase as Application:UseCase
    participant DomainRepo as Domain:Repository
    participant InfraDB as Infrastructure:DataBase
    participant InfraNet as Infrastructure:Network
    
    Client->>AppRoute: File Request
    AppRoute->>AppUseCase: Receive File
    AppUseCase->>DomainRepo: Request save with UUID
    DomainRepo->>InfraDB: Request save file
    InfraDB-->>DomainRepo: Return file info
    Note over InfraDB: Info {fileName, SampleRate, Channel }
    DomainRepo-->>AppUseCase: Return file info
    AppUseCase->>DomainRepo: Request save to GCP
    DomainRepo->>InfraNet: Request save file to GCP
    InfraNet-->>DomainRepo: Return file info
    DomainRepo-->>AppUseCase: Return file info
    
    AppUseCase->>DomainRepo: Request SpeechToText
    DomainRepo->>InfraNet: Request SpeechToText
    InfraNet-->>DomainRepo: Return text
    DomainRepo-->>AppUseCase: Return text
    
    AppUseCase->>Client: Respond with text

```


### サーバAのChatAPIの仕様
リクエスト
```json
{
  "userId":"user id"
  "text":"new users message"
}
```
レスポンス
```json
{
  /**
  @id : 会話順 0~ インクリメント
  @role : 0: assistant, 1: user
  */
  "conversation":[
    {
      "id":"int",
      "role":"int: 0,1",
      "message":"string: message"
    }
  ],
  
  /**
  * @param errorCode
  *  0 : 想定外
  *  1 : トークン数が多すぎる（しゃべりすぎ）
  *  2 : chatAPIのfinish_reason が stop以外(なんらかの生成エラー?)
  */
  "errorCode":"Int: 0~2, nullable"
}
```
チャット系
- 永続化する。
スキーマ定義
